<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>DOM入门 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="DOM简介 1.文档对象模型（Document Object Model，简称DOM）是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一">
<meta property="og:type" content="article">
<meta property="og:title" content="DOM入门">
<meta property="og:url" content="http://yoursite.com/2019/01/19/DOM入门/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="DOM简介 1.文档对象模型（Document Object Model，简称DOM）是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.loli.net/2019/01/19/5c42b1359999b.jpg">
<meta property="og:updated_time" content="2019-01-19T06:40:24.877Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DOM入门">
<meta name="twitter:description" content="DOM简介 1.文档对象模型（Document Object Model，简称DOM）是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一">
<meta name="twitter:image" content="https://i.loli.net/2019/01/19/5c42b1359999b.jpg">
<meta name="twitter:creator" content="@coolwuxing">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43935113-3', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="banner">
    <div id="cover"></div>
    <div id="stars"></div>
  </div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-DOM入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/DOM入门/" class="article-date">
  <time datetime="2019-01-19T05:00:31.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      DOM入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><ul>
<li><p>1.文档对象模型（Document Object Model，简称DOM）<br>是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有VBScript、ActiveX、以及微软自家的DHTML格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。</p>
</li>
<li><p>2.节点<br>根据 DOM，HTML 文档中的每个成分都是一个节点。<br>DOM 是这样规定的：</p>
</li>
<li>整个文档是一个文档节点</li>
<li>每个 HTML 标签是一个元素节点</li>
<li>包含在 HTML 元素中的文本是文本节点</li>
<li>每一个 HTML 属性是一个属性节点</li>
<li><p>注释属于注释节点</p>
</li>
<li><p>3.Node层次<br>节点彼此都有等级关系。<br>HTML 文档中的所有节点组成了一个文档树（或节点树）。HTML 文档中的每个元素、属性、文本等都代表着树中的一个节点。树起始于文档节点，并由此继续伸出枝条，直到处于这棵树最低级别的所有文本节点为止。<br><img src="https://i.loli.net/2019/01/19/5c42b1359999b.jpg" alt="节点树示意图"></p>
</li>
<li><p>4.优点和缺点<br>DOM的优势主要表现在：易用性强，使用DOM时，将把所有的XML文档信息都存于内存中，并且遍历简单，支持XPath，增强了易用性。</p>
</li>
</ul>
<p>DOM的缺点主要表现在：效率低，解析速度慢，内存占用量过高，对于大文件来说几乎不可能使用。另外效率低还表现在大量的消耗时间，因为使用DOM进行解析时，将为文档的每个element、attribute、processing-instruction和comment都创建一个对象，这样在DOM机制中所运用的大量对象的创建和销毁无疑会影响其效率。</p>
<h2 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h2><ul>
<li><ol>
<li>document.getElementById ：<br>（1）参数</li>
</ol>
</li>
<li>根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；</li>
<li>element是一个 Element 对象。如果当前文档中拥有特定ID的元素不存在则返回null.<br>（1）返回值</li>
<li>返回一个匹配到 ID 的 DOM Element 对象。若在当前 Document 下没有找到，则返回 null。</li>
</ul>
<p>由于元素的 ID 在大部分情况下要求是独一无二的，这个方法自然而然地成为了一个高效查找特定元素的方法。不同于其他 Element 查找方法（如Document.querySelector() 以及 Document.querySelectorAll()），getElementById() 只有在作为 document 的方法时才能起作用，而在DOM中的其他元素下无法生效。这是因为 ID 值在整个网页中必须保持唯一。因此没有必要为这个方法创建所谓的 “局部” 版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(id);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><ol start="2">
<li>document.getElementsByClassName ：<br>根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByClassName(names); // or:</span><br><span class="line">var elements = rootElement.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>elements 是一个实时集合，包含了找到的所有元素。</p>
</li>
<li>names 是一个字符串，表示要匹配的类名列表；类名通过空格分隔</li>
<li><p>getElementsByClassName 可以在任何元素上调用，不仅仅是 document。 调用这个方法的元素将作为本次查找的根元素.</p>
</li>
<li><ol start="3">
<li>document.getElementsByTagName ：<br>根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var elements = document.getElementsByTagName(name);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>elements 是一个由发现的元素出现在树中的顺序构成的动态的HTML集合 HTMLCollection 。</p>
</li>
<li><p>name 是一个代表元素的名称的字符串。特殊字符 “*” 代表了所有元素。<br><strong>注意：</strong>当在一个HTML 文件上执行时， getElementsByTagName() 会在执行前把参数转换为小写字母。这是试着在一个HTML文件的子树匹配驼峰命名法的 SVG 元素时不希望的。 document.getElementsByTagNameNS() 在那种情况下会有用. </p>
</li>
<li><ol start="4">
<li>document.getElementsByName ：<br>根据元素的name属性查找，返回一个 NodeList 。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elements = document.getElementsByName(name);</span><br></pre></td></tr></table></figure>
<ul>
<li>elements 是一个实时更新的 NodeList 集合。</li>
<li>name 是元素的 name 属性的值。<br><strong>注意：</strong></li>
<li>getElementsByName  在不同的浏览器其中工作方式不同。在IE和Opera中， getElementsByName()  方法还会返回那些 id 为指定值的元素。所以你要小心使用该方法，最好不要为元素的 name 和 id 赋予相同的值。 </li>
<li><p>IE 和 Edge 都返回一个 HTMLCollection, 而不是NodeList 。</p>
</li>
<li><ol start="5">
<li>document.querySelector ：<br>返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。如果找不到匹配项，则返回null。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = document.querySelector(selectors);</span><br></pre></td></tr></table></figure>
<p>（1）参数</p>
<ul>
<li>selectors包含一个或多个要匹配的选择器的 DOM字符串DOMString。 该字符串必须是有效的CSS选择器字符串；如果不是，则引发SYNTAX_ERR异常。<br><strong>提示:</strong>必须使用反斜杠字符转义不属于标准CSS语法的字符。 由于JavaScript也使用退格转义，因此在使用这些字符编写字符串文字时必须特别小心。<br>（2）返回值</li>
<li>表示文档中与指定的一组CSS选择器匹配的第一个元素的 html元素Element对象。<br>（3）异常</li>
<li><p>SYNTAX_ERR指定selectors的语法无效。</p>
</li>
<li><ol start="6">
<li>document.querySelectorAll ：<br>返回一个 NodeList ，IE8+(含）。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementList = parentNode.querySelectorAll(selectors);</span><br></pre></td></tr></table></figure>
<p>（1）参数</p>
<ul>
<li>一个 DOMString 包含一个或多个匹配的选择器。这个字符串必须是一个合法的 CSS selector 如果不是，会抛出一个 SyntaxError 错误。<br>（2）返回值</li>
<li>一个静态 NodeList，包含一个与至少一个指定选择器匹配的元素的Element对象，或者在没有匹配的情况下为空NodeList。<br>（3）异常</li>
<li>SyntaxError如果指定的 选择器 不合法，会抛出错误。如$(“##div”)</li>
</ul>
<ul>
<li><ol start="7">
<li>document.forms ：<br>获取当前页面所有form，返回一个 HTMLCollection ；</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let collection = document.forms;</span><br></pre></td></tr></table></figure>
<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p>Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。<br>以下接口都从Node继承其方法和属性：<br>Document, Element, Attr, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference。<br>在方法和属性不相关的特定情况下，这些接口可能返回null。它们可能会抛出异常 - 例如，当将子节点添加到不允许子节点存在的节点时。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>从其父类EventTarget继承属性。</p>
<ul>
<li><ol>
<li>Node.childNodes（只读）<br>返回一个包含了该节点所有子节点的实时的NodeList。NodeList 是“实时的”意思是，如果该节点的子节点发生了变化，NodeList对象就会自动更新。</li>
</ol>
</li>
<li><ol start="2">
<li>Node.firstChild （只读）<br>返回该节点的第一个子节点Node，如果该节点没有子节点则返回null。</li>
</ol>
</li>
<li><ol start="3">
<li>Node.isConnected（只读）<br>返回一个布尔值用来检测该节点是否已连接(直接或者间接)到一个上下文对象上，比如通常DOM情况下的Document对象，或者在shadow DOM情况下的ShadowRoot对象。</li>
</ol>
</li>
<li><ol start="4">
<li>Node.lastChild （只读）<br>返回该节点的最后一个子节点Node，如果该节点没有子节点则返回null。</li>
</ol>
</li>
<li><ol start="5">
<li>Node.nextSibling （只读）<br>返回与该节点同级的下一个节点 Node，如果没有返回null。</li>
</ol>
</li>
<li><ol start="6">
<li>Node.nodeName （只读）<br>返回一个包含该节点名字的DOMString。节点的名字的结构和节点类型不同。比如HTMLElement的名字跟它所关联的标签对应，就比如HTMLAudioElement的就是 ‘audio’ ，Text节点对应的是 ‘#text’ 还有Document节点对应的是 ‘#document’。</li>
</ol>
</li>
<li><ol start="7">
<li>Node.nodeType（只读）<br>返回一个与该节点类型对应的无符号短整型的值，后面作为重点详细介绍。</li>
</ol>
</li>
<li><ol start="8">
<li>Node.parentNode （只读）<br>返回一个当前结点 Node的父节点 。如果没有这样的结点,，比如说像这个节点是树结构的顶端或者没有插入一棵树中， 这个属性返回null。</li>
</ol>
</li>
<li><ol start="9">
<li>Node.parentElement （只读）<br>返回一个当前节点的父节点 Element 。 如果当前节点没有父节点或者说父节点不是一个元素(Element), 这个属性返回null。</li>
</ol>
</li>
<li><ol start="10">
<li>Node.previousSibling （只读）<br>返回一个当前节点同辈的前一个结点( Node) ，或者返回null（如果不存在这样的一个节点的话）。</li>
</ol>
</li>
</ul>
<h3 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h3><p>nodeType 属性可用来区分不同类型的节点，比如 元素, 文本 和 注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var type = node.nodeType;</span><br></pre></td></tr></table></figure></p>
<p>返回一个整数，其代表的是节点类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Node.ELEMENT_NODE</td>
<td style="text-align:center">1</td>
<td style="text-align:center">一个 元素 节点，例如 <code>&lt;p&gt;</code> 和 <code>&lt;div&gt;</code>。</td>
</tr>
<tr>
<td style="text-align:left">Node.TEXT_NODE</td>
<td style="text-align:center">3</td>
<td style="text-align:center">Element 或者 Attr 中实际的 文字</td>
</tr>
<tr>
<td style="text-align:left">Node.PROCESSING_INSTRUCTION_NODE</td>
<td style="text-align:center">7</td>
<td style="text-align:center">一个用于XML文档的 ProcessingInstruction ，例如 <code>&lt;?xml-stylesheet ... ?&gt;</code> 声明。</td>
</tr>
<tr>
<td style="text-align:left">Node.COMMENT_NODE</td>
<td style="text-align:center">8</td>
<td style="text-align:center">一个 Comment 节点。</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_NODE</td>
<td style="text-align:center">9</td>
<td style="text-align:center">一个 Document 节点。</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_TYPE_NODE</td>
<td style="text-align:center">10</td>
<td style="text-align:center">描述文档类型的 DocumentType 节点。例如 <code>&lt;!DOCTYPE html&gt;</code> 就是用于 HTML5 的。</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_FRAGMENT_NODE</td>
<td style="text-align:center">11</td>
<td style="text-align:center">一个 DocumentFragment 节点。</td>
</tr>
</tbody>
</table>
<h2 id="节点创建API"><a href="#节点创建API" class="headerlink" title="节点创建API"></a>节点创建API</h2><p>节点创建API主要包括 createElement 、 createTextNode 、 cloneNode 和 createDocumentFragment 四个方法。</p>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let element = document.createElement(tagName[, options]);</span><br></pre></td></tr></table></figure>
<p>（1）参数</p>
<ul>
<li>tagName<br>指定要创建元素类型的字符串,创建元素时的nodeName使用tagName的值为初始化,该方法不接受使用限定名称(如:”html:a”),在HTML文档上调用createElement()方法创建元素之前会将tagName转化成小写,在Firefox, Opera 和 Chrome内核中. createElement(null) 等同于 createElement(“null”)</li>
<li>options(可选)<br>一个可选的参数 ElementCreationOptions 是包含一个属性名为 is的对象, 该对象的值是用 customElements.define()方法定义过的一个自定义元素的标签名。 为了向前兼容较老版本的 Custom Elements specification, 有一些浏览器会允许你传一个值为自定义元素的标签名的字符串作为该参数的值. 可以看 Extending native HTML elements 仔细了解如何使用该参数。<br>这个新元素会有一个 is 属性，该属性值为自定义元素的标签名。注意，自定义元素是一项只在某些浏览器可用的实验性特性。</li>
</ul>
<p>（2）返回值<br>The new Element.</p>
<ul>
<li>element 是创建的Element对象。</li>
<li>tagName 指定将要创建的元素类型的字符串。创建的element的nodeName会被初始化为tagName的值。该方法不接受带条件的元素名字(例如: html:a)。</li>
<li>options 是一个可选的 ElementCreationOptions 对象. 如果这个对象被定义并赋予了一个 is 特性，则创建的element的 is 属性会被初始化为这个特性的值. 如果这个对象没有 is 特性，则值为空.</li>
</ul>
<h3 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h3><p>创建一个新的文本节点.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var text = document.createTextNode(data);</span><br></pre></td></tr></table></figure></p>
<p>(1)参数</p>
<ul>
<li>text 是一个文本节点.</li>
<li>data 是一个字符串,包含了放在文本节点中的内容.</li>
</ul>
<p>###　cloneNode<br>Node.cloneNode() 方法返回调用该方法的节点的一个副本.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dupNode = node.cloneNode(deep);</span><br></pre></td></tr></table></figure></p>
<p><strong>node</strong><br>将要被克隆的节点<br><strong>dupNode</strong><br>克隆生成的副本节点<br><strong>deep</strong> (可选)<br>是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身.</p>
<h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h3><p>创建一个新的空白的文档片段( DocumentFragment)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fragment = document.createDocumentFragment();</span><br></pre></td></tr></table></figure></p>
<p>fragment 是一个指向空DocumentFragment对象的引用。</p>
<h2 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h2><p>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><p>Node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child = node.appendChild(child);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>node 是要插入子节点的父节点.</li>
<li>child 即是参数又是这个方法的返回值.</li>
</ul>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>###　removeChild</p>
<h3 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/19/DOM入门/" data-id="cjr330u1k0000n4pmja5lnslv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/12/22/原型与原型链/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">原型与原型链</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/19/DOM入门/">DOM入门</a>
          </li>
        
          <li>
            <a href="/2018/12/22/原型与原型链/">原型与原型链</a>
          </li>
        
          <li>
            <a href="/2018/12/20/JS里的数据类型转换及一些面试题的坑/">JS里的数据类型转换及一些面试题的坑</a>
          </li>
        
          <li>
            <a href="/2018/12/18/JS里的数据类型/">JS里的数据类型</a>
          </li>
        
          <li>
            <a href="/2018/11/17/CSS的一般布局的实现/">CSS的一般布局的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <div id="footer">
  
  <div id='foot-stars'></div>
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lianglu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>